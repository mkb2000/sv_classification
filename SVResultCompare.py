'''
A class used for comparing the result from rule-based approach with the standard (the breakpoint file generated by simulation).

Created on Jan 8, 2014

@author: HELE

myresult format:
inversion    1042396    1047438
tandem    1047438    111063799
deletion    1921532    1921699
inversion    3621811    3700999
interspersed insertion    4532649    4532654    5794270    5795075

standard:
1042399    1047437    INV    5038
1042400    1047438    INV    5038
1921534    1921699    DEL    164
3621811    3700996    INV    79185
3621812    3700997    INV    79185
4532654    5794270    FUS    805
'''
from svDetectFuncs import delimeter
from sets import Set

class SVResultComapreClass(object):
    '''
    classdocs
    '''
    tolerence=15
    
    def mySvTypesToAbbre(self,str):
        mapDict={"tandem":["TAN"],
                 "interspersed insertion":["FUS"],
                 "inversion":["INV"],
                 "deletion":["DEL"],
                 "novel insertion":["INS"],
                 "translocation":["FUS","DEL"],
                 "error":["error"],
                 "deleted for translocation":["deleted for translocation"]}
        try:
            mapDict[str]
        except:
            print str
        return mapDict[str]
    
    def __init__(self,myResult,standardFile,socratesFile,eventFromBkFile):
        self.myresult=myResult.strip().split("\n")
        self.stand=open(standardFile,"r").readlines()
        self.comparedResult=[]
        self.socratesOutput=open(socratesFile,"r").readlines()[1:]
        self.newbkfile=open(eventFromBkFile,"r").readlines()
        self.totalRelative=len(open(eventFromBkFile,"r").readlines())
        
    #TODO: new compare method to replace the old compare().
    #delete DEL in self.newbkfile if it is part of translocation. then use it as the standard for comparison. recalculate recall and presion.
    def compare2(self):
        return
        
    #TODO: handle error type.
    def compare(self):
        i=k=0
        for myr in self.myresult:
            myr=myr.strip().split(delimeter)
            svtype=self.mySvTypesToAbbre(myr[0])
            breakpoints=myr[1:]
            self.comparedResult.append([])
            #actually, these ifs are not necessary here. result already deleted those cases.
            if svtype[0]=="deleted for translocation":
                self.comparedResult[i].append(-2)
            elif svtype[0]=="error":
                self.comparedResult[i].append(-11)
            else:
                k=0
                for gospel in self.stand: # search all the breakpoint file, find any breakpoint has same svtype and close event points.
                    for svt in svtype:
                        s=0
                        if svt in gospel:
                            tempGospel=gospel.strip().split(delimeter)
                            startp=int(tempGospel[0])
                            endp=int(tempGospel[1])
                            for bk in breakpoints:
                                if abs(int(bk)-startp)<self.tolerence or abs(int(bk)-endp)<self.tolerence:
                                    s+=1
                            if s>=2:
                                self.comparedResult[i].append(k)
                    k+=1
            i+=1
        self.correctResult=[]
        self.usedBreakpoints=[]
        for e in self.comparedResult:
            if len(e)>0:
                self.correctResult.append(e);
                for bk in e:
                    self.usedBreakpoints.append(bk);
        breakpointsInStand=Set(list(xrange(len(self.stand))))
        breakpointsUsed=Set(self.usedBreakpoints)
        breakpointsUnused=sorted(breakpointsInStand-breakpointsUsed)
        print "breakpointsUnused: ",len(breakpointsUnused)
        for bk in breakpointsUnused:
            bkstr=self.stand[bk]
            bkstr=bkstr.strip().split(delimeter)
            bks=bkstr[0]
            bke=bkstr[1]
            if (self.bkInSocratesOutput(int(bks)) and self.bkInSocratesOutput(int(bke))):
                print "breakpoints that mis-classified: No.",bk,":",bkstr
                continue
            elif (self.bkInSocratesOutput(int(bks)) or self.bkInSocratesOutput(int(bke))):
                print "breakpoints that wrongly detected by Socrates: No.",bk,":",bkstr
                continue
            else:
                self.totalRelative-=1
                print "breakpoints that not detected by Socrates: No.",bk,":",bkstr
            

    #recall=correct/total relevant  
    def recall(self):
        self.recal=float(len(self.correctResult))/self.totalRelative
        return self.recal
    
    #precision=correct/retrieved
    def precision(self):
        self.precis=float(len(self.correctResult))/len(self.comparedResult)
        return self.precis
            
# C1_realign[0]
# C1_realign_dir[1]
# C1_realign_consensus[2]
# C1_anchor[3]
# C1_anchor_dir[4]
# C1_anchor_consensus[5]
# C1_long_support[6]
# C1_long_support_bases[7]
# C1_short_support[8]
# C1_short_support_bases[9]
# C1_short_support_max_len[10]
# C1_avg_realign_mapq[11]
# C2_realign[12]
# C2_realign_dir[13]
# C2_realign_consensus[14]
# C2_anchor[15]
# C2_anchor_dir[16]
# C2_anchor_consensus[17]
# C2_long_support[18]
# C2_long_support_bases[19]
# C2_short_support[20]
# C2_short_support_bases[21]
# C2_short_support_max_len[22]
# C2_avg_realign_mapq[23]        
    def bkInSocratesOutput(self,bk):
        for l in self.socratesOutput:
            l=l.strip().split(delimeter)
            c1_realign=int(l[0].split(":")[1])
            c1_anchor=int(l[3].split(":")[1])
            c2_realign=int(l[12].split(":")[1])
            c2_anchor=int(l[15].split(":")[1])
            if abs(c1_realign-bk)<self.tolerence or abs(c2_realign-bk)<self.tolerence or abs(c1_anchor-bk)<self.tolerence or abs(c2_anchor-bk)<self.tolerence:
                return True
        return False
            
        
#     def writeCompareResult(self):
        
        